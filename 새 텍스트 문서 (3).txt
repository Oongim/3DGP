가상함수: 호출하는 함수가 포인터로 쓰이는 변수의 타입이 아니라 포인터가 가리키는 실제 객체의 타입으로 호출 될 수 있게 해줌

메쉬: (3차원에선 실수 3개의 좌표로 )연결된 점들의 집합

랜더링: T&L 

x축: right 벡터
y축: up 벡터
z축: look 벡터

모델 : 형태가 바뀌지 않음 위치와 모양 안바뀜

인스턴싱: 어떤 모델을 가지고 재사용을 하는 것

정적인 객체: 움직이지 않는 객체  2d로 처리 할 수 있음
1. batch 처리(일괄) - 유사한 일들을 모아서 한꺼번에 처리하는 것

2. 미리 계산(정적) 후 저장해서 계속 사용 

파이프 라인

투영된 것들을 2d로 화면에 어디로 어떻게 그리느냐 -화면 변환

월드변환- 월드좌표의 좌표를 반환하는 함수로 만들 수 있다

인스턴스- 객체지향언어에서 클래스를 오브젝트로 만드는 과정

모델은 1개 객체는 모델에 대한 포인터가 있고 평행이동 시킴 게임 오브젝트:메쉬에 대한 포인터, 오브젝트에 대한 위치를 표시

인스턴싱-하나의 메쉬를 여러 객체에서 공유하는 방법 

행렬은 교환법칙 성립 x, AB=BA

x축 pitch  y축 Yaw z축 Roll  회전



모델->월드 좌표->카메라 좌표  ->2d로 변환  -> 모니터 화면

원근감을 표현해야됨(수학적으로, 직각삼각형에서 빗변에서 수선의 발을 내리는 것도 투영)

y를 0으로 직교로 내리면 직교투영

카메라 좌표(x,y,z)를 z로 나눔->(x/z,y/z,1) 1 생략 가능-> 2d좌표  =원근 투영 나누기 (입체를 사각형으로 나눈다)

y/z (1=|(45도 윗 삼각형 면에 있는 점들)| or +-1>|(카메라에 나오는 점)| or 1<|(카메라에 안보이는 점들)|)
==> 1. 3D->2D  2. 1>=|x/z,y/z| -> 카메라에 나오는 점들(FOV 90도 일 때), 3.원근감이 생긴다.

멀리있는 애들은 0에 가까워진다(카메라 중심점에 모임) 밴시포인트

대부분의 FOV는 60아래  (FOV가 작으면 속도감이 느껴짐-적게 움직여도 빠르게 움직임)

frame rate 좋아지는 법(FOV를 작게하기, 멀리 보이는 거리를 줄이기(원평면 까지의 거리))-그릴게 적어짐

크게 보이면 자세하게, 멀리 보이면 대충 그려도 됨(사진 한장으로도 처리가능)-> LOD(Level(카메라하고 그릴 놈의 거리) of Detail)

FOV가 90도 보다 작아도 투영 평면과 카메라사의의 거리(==tan 세타,90도로 처리하기 위해 tan 세타로 나눠서 1로 만들수 있음으로)로 z값을 나누면 90도 처럼 처리 가능





벡터
1. 방향/크기 를 알기 위해

2 점(위치) 를 알기 위해(원점(0,0,0) 필요) 
벡터의 시작점을 원점으로 평행이동 시키면 벡터의 끝점이 가리키는 절대적인 위치를 이해 할 수 있다
벡터는 원론적으로 상대적인 크기 비교를 못하지만, 위치는 원점이 존재하므로 가능


이동 : 벡터의 덧셈

A에서 B로 이동: B-A 뺄셈

정규화
단위벡터= 크기가 1인 벡터 (방향만 표시) 



-----------------------------------------


오른손 좌표계 : 좌표가 오른쪽 열벡터(세로) M*v

왼손 좌표계 : 좌표가 왼쪽 행벡터(가로)  v*M  DirectX

 M(월드좌표계)*v(모델 좌표계) -> 월드 좌표계 정점 얻음


월드 변환 행렬로 바꿀 때 찌그러져도 축들이 직교 할 수 있도록 만들어줌


왼손 좌표계와 오른손 좌표계의 변환 행렬은 행과 열이 바뀜
(M*v)T  =vT*MT


카메라 월드 변환 행렬의 역행렬은 카메라 변환 행렬


카메라 변환: 카메라를 중심으로 게임 월드의 객체들의 위치와 방향을 변환
카메라 변환 행렬을 만들기 위해 벡터들을 그대로 사용(함수로 채워넣음 바로)
(D3DXMatrixLookAtL(left)H(hand))(월드 좌표계에서 카메라 위치, 카메라가 어디를 보고 있는가,카메라의 위쪽 방향))

하나의 벡터를 외적연산 두번으로 모든 축을 찾을 수 있음



행렬의 결합- 결합법칙으로 변환 행렬들을 묶으면 연산 횟수를 줄일 수 있다









충돌 검사 시

모델들의 점들을 월드 좌표계로 바꾸는 거 보다
월드 좌표계에서 충돌 체크 해야 하는 것을 각각의 모델 좌표계로 바꿔서 계산하는 것이 효율적

월드 변환 행렬은 오브젝트 마다 있음 (월드 변환 마다 오브젝트 필요,오브젝트와 상대적인 모델좌표계가 나옴)









원큰 투영 나누기는 행렬로 할 수 없음 (z가 계속 변해서 미리 만들 수 없음)

원근 투영 변환 행렬이 필요한 경우
fov 90도가 아닐 경우 
화면이 정사각형이 아님(가로가 늘어남) 종횡비(세로를 1이라고 했을 때 늘어나는 가로비)

원근 투영 나누기 전에 메쉬를 왜곡(FOV를 90도 처럼d(1/tan(FOV/2))를 곱함, 정사각형으로 스케일링)시킨 후 z로 나눔

(x,y,z,1)을 원근 투영 변환 한 것을 (x',y',1,1)이 되면 역행렬을 구할 수 없으므로 (x',y',1,z)로 해서 깊이 값을 저장해 놀 수 있다(w 친화행렬)





PM
D3DXMatrixPerspectiveFovLH-> 95p 행렬을 리턴해줌
z는 근평면일 때 0, 원평면일 때 1
|x,y| <=1
0<=z<=1 일때 화면에 보임



직교투영
z축이 수직으로 투영됨 절도체가 직육면체 형태가 됨
멀리 있던 가까이 있던 같은 크기 (ex, UI 그릴 때)




뷰포트
x,y는 -1과 1사이의 값
실제 투영 사각형이 그려질 픽셀 영역
-y 투영과 좌표계가 서로 반대여서




픽킹
오브젝트를 마우스로 선택할 수 있게 해줌
월드 좌표계의 벡터를 알아야 함
화면 좌표계의 2d점을 역(행렬)변환으로 투영좌표계 -(프로젝션 변환행렬)> 카메라 좌표계-> 월드좌표계

원근투영나누기를 하면 사각형은 2d의 의미로 바뀜 투영 사각형은 z좌표계가 1이라고 생각해도 되므로 2d
투영 사각형의 위치가 1이 되도록 만듬  그래서 1 (100p 아래 계산식)

정사각형으로 만들기 위해 찌그려 트리려고 스케일 곱한걸 다시 나눔 (100p 아래 오른쪽 계산식)

직선상에 점중에 카메라에서 가장 가까운(z값이 가장 작은)점을 찾음
원점(0,0,0)에서 직선의 투영평면 점(x,y,1)벡터를 스칼라곱한 것으로 찾음









=====================================================
렌더링
1.Clear
2.Render
3.Present 

	  hDCFrameBuffer  -메모리 그림
프레임워크= BitmapFrameBuffer - 화면에 그린 한장


BuildFB= 메모리 버퍼에 그림
ClearFB= 메모리 버퍼 초기화
PresentFB= 현재 그려진 그림


BuildObj- 오브젝트를만듬

===================================================
















