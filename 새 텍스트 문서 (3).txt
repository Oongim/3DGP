가상함수: 호출하는 함수가 포인터로 쓰이는 변수의 타입이 아니라 포인터가 가리키는 실제 객체의 타입으로 호출 될 수 있게 해줌

메쉬: (3차원에선 실수 3개의 좌표로 )연결된 점들의 집합

랜더링: T&L 

x축: right 벡터
y축: up 벡터
z축: look 벡터

모델 : 형태가 바뀌지 않음 위치와 모양 안바뀜

인스턴싱: 어떤 모델을 가지고 재사용을 하는 것

정적인 객체: 움직이지 않는 객체  2d로 처리 할 수 있음
1. batch 처리(일괄) - 유사한 일들을 모아서 한꺼번에 처리하는 것

2. 미리 계산(정적) 후 저장해서 계속 사용 

파이프 라인

투영된 것들을 2d로 화면에 어디로 어떻게 그리느냐 -화면 변환

월드변환- 월드좌표의 좌표를 반환하는 함수로 만들 수 있다

인스턴스- 객체지향언어에서 클래스를 오브젝트로 만드는 과정

모델은 1개 객체는 모델에 대한 포인터가 있고 평행이동 시킴 게임 오브젝트:메쉬에 대한 포인터, 오브젝트에 대한 위치를 표시

인스턴싱-하나의 메쉬를 여러 객체에서 공유하는 방법 

행렬은 교환법칙 성립 x, AB=BA

x축 pitch  y축 Yaw z축 Roll  회전



모델->월드 좌표->카메라 좌표  ->2d로 변환  -> 모니터 화면

원근감을 표현해야됨(수학적으로, 직각삼각형에서 빗변에서 수선의 발을 내리는 것도 투영)

y를 0으로 직교로 내리면 직교투영

카메라 좌표(x,y,z)를 z로 나눔->(x/z,y/z,1) 1 생략 가능-> 2d좌표  =원근 투영 나누기 (입체를 사각형으로 나눈다)

y/z (1=|(45도 윗 삼각형 면에 있는 점들)| or +-1>|(카메라에 나오는 점)| or 1<|(카메라에 안보이는 점들)|)
==> 1. 3D->2D  2. 1>=|x/z,y/z| -> 카메라에 나오는 점들(FOV 90도 일 때), 3.원근감이 생긴다.

멀리있는 애들은 0에 가까워진다(카메라 중심점에 모임) 밴시포인트

대부분의 FOV는 60아래  (FOV가 작으면 속도감이 느껴짐-적게 움직여도 빠르게 움직임)

frame rate 좋아지는 법(FOV를 작게하기, 멀리 보이는 거리를 줄이기(원평면 까지의 거리))-그릴게 적어짐

크게 보이면 자세하게, 멀리 보이면 대충 그려도 됨(사진 한장으로도 처리가능)-> LOD(Level(카메라하고 그릴 놈의 거리) of Detail)

FOV가 90도 보다 작아도 투영 평면과 카메라사의의 거리(==tan 세타,90도로 처리하기 위해 tan 세타로 나눠서 1로 만들수 있음으로)로 z값을 나누면 90도 처럼 처리 가능





벡터
1. 방향/크기 를 알기 위해

2 점(위치) 를 알기 위해(원점(0,0,0) 필요) 
벡터의 시작점을 원점으로 평행이동 시키면 벡터의 끝점이 가리키는 절대적인 위치를 이해 할 수 있다
벡터는 원론적으로 상대적인 크기 비교를 못하지만, 위치는 원점이 존재하므로 가능


이동 : 벡터의 덧셈

A에서 B로 이동: B-A 뺄셈

정규화
단위벡터= 크기가 1인 벡터 (방향만 표시) 



=====================================================
렌더링
1.Clear
2.Render
3.Present 

	  hDCFrameBuffer  -메모리 그림
프레임워크= BitmapFrameBuffer - 화면에 그린 한장


BuildFB= 메모리 버퍼에 그림
ClearFB= 메모리 버퍼 초기화
PresentFB= 현재 그려진 그림


BuildObj- 오브젝트를만듬

===================================================
















